# -*- coding: utf-8 -*-
"""RafiAnandaSubekti_Submission2_MLT.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1JvU1vdN5puXlDf-TaI_RErSROQQmOMN-

# Music Recommendation System

- **Nama:** Rafi Ananda Subekti
- **Email:** rafiasubekti@gmail.com
- **ID Dicoding:** MC009D5Y0612

# Domain Proyek
Proyek ini berfokus pada domain musik digital, khususnya analisis data yang berasal dari platform streaming Spotify, salah satu layanan musik terbesar dan paling populer di dunia saat ini. Dengan jutaan lagu yang tersedia, Spotify menyediakan beragam informasi mengenai setiap lagu, termasuk fitur audio yang menggambarkan karakteristik musik secara detail, serta data popularitas yang mencerminkan seberapa sering lagu tersebut diputar oleh pengguna. Proyek ini bertujuan untuk menggali dan memahami berbagai aspek tersebut agar dapat memperoleh wawasan mendalam tentang tren musik dan preferensi pendengar secara global.

Fokus utama analisis adalah pada karakteristik lagu yang diwakili oleh fitur-fitur seperti danceability, energy, valence, acousticness, dan tempo. Fitur-fitur ini memberikan gambaran objektif tentang sifat musikal suatu lagu yang dapat mempengaruhi bagaimana lagu tersebut diterima oleh pendengar. Selain itu, proyek ini juga mengevaluasi popularitas lagu di berbagai playlist dan genre, yang membantu dalam memahami pola konsumsi musik berdasarkan preferensi genre dan konteks playlist tertentu. Dengan demikian, proyek ini tidak hanya mengidentifikasi lagu-lagu populer, tetapi juga mengeksplorasi hubungan antara fitur audio dan popularitas.

# Business Understanding

## Problem Statements

Rumusan masalah dari masalah latar belakang diatas adalah:
1. Apa saja top 10 Lagu dari Playlist "Global Top 50 | 2020 Hits"?
2. Apa saja 5 Genre Lagu Teratas dengan Rata-rata memiliki Popularitas Tertinggi?
3. Apakah ada korelasi Korelasi antara Energy dan Popularitas Lagu?

## GOALS

Berdasarkan problem statements, berikut tujuan yang ingin dicapai pada proyek ini.
1. Mengidentifikasi 10 lagu dengan popularitas tertinggi dalam playlist "Global Top 50 | 2020 Hits" guna memahami lagu-lagu yang paling diminati secara global pada tahun 2020.
2. Menentukan 5 genre dengan rata-rata popularitas tertinggi untuk mengetahui preferensi pendengar terhadap genre tertentu.
3. Menganalisis hubungan antara tingkat energi lagu dan popularitas untuk mengetahui apakah lagu yang lebih energik cenderung lebih populer.

## Solution Statements

1. Data akan difilter berdasarkan nama playlist, lalu diurutkan berdasarkan nilai popularitas lagu secara menurun, dan diambil 10 lagu teratas sebagai hasil akhir.
2. Data akan difilter berdasarkan nama playlist, lalu diurutkan berdasarkan nilai popularitas lagu secara menurun, dan diambil 10 lagu teratas sebagai hasil akhir.
3. Menghitung koefisien korelasi Pearson antara kolom energy dan track_popularity, disertai dengan visualisasi scatter plot dan garis regresi untuk memperkuat interpretasi hubungan antara kedua variabel tersebut.

# Data Understanding

Data Understanding adalah tahap awal dalam proses analisis data yang berfungsi untuk mengenal dan memahami data secara menyeluruh. Pada tahap ini, kita memeriksa struktur data, jenis informasi yang terkandung, serta kualitas data yang ada, seperti kelengkapan dan konsistensi.

## Mengimport Library

Sebelum memulai analisis data, langkah pertama yang perlu dilakukan adalah mengimpor library atau pustaka yang diperlukan untuk membantu proses pengolahan, visualisasi, dan analisis data.
"""

import pandas as pd
from sklearn.feature_extraction.text import TfidfVectorizer
from sklearn.metrics.pairwise import cosine_similarity

import matplotlib.pyplot as plt
import seaborn as sns

"""## Data Loading

Data Loading merupakan tahap di mana data diambil atau dimasukkan dari sumber luar ke dalam lingkungan kerja agar dapat dilakukan pemrosesan dan analisis lebih lanjut.
"""

#!/bin/bash
!curl -L -o music.zip\
  "https://www.kaggle.com/api/v1/datasets/download/joebeachcapital/30000-spotify-songs"

!unzip music.zip -d music

df = pd.read_csv("/content/music/spotify_songs.csv")
df

"""**Insight:**
- Pada tabel diatas dapat dilihat bahwa terdapat 23 kolom
- Pada tabel diatas juga terdapat 32.833 data

## Deskripsi Variabel
"""

df.head()

df.info()

"""
| **Kolom**                    | **Tipe Data** | **Deskripsi** |
|-----------------------------|---------------|---------------|
| `track_id`                  | object        | ID unik untuk setiap lagu. Digunakan sebagai pengenal utama. |
| `track_name`                | object        | Nama atau judul lagu. |
| `track_artist`              | object        | Nama artis atau penyanyi dari lagu. |
| `track_popularity`          | int64         | Skor popularitas (0–100) berdasarkan metrik Spotify seperti jumlah pemutaran. |
| `track_album_id`            | object        | ID unik dari album tempat lagu berasal. |
| `track_album_name`          | object        | Nama album dari lagu. |
| `track_album_release_date` | object        | Tanggal rilis album dalam format string (YYYY-MM-DD). |
| `playlist_name`             | object        | Nama playlist yang memuat lagu tersebut. |
| `playlist_id`               | object        | ID unik dari playlist. |
| `playlist_genre`            | object        | Genre utama playlist, seperti pop, rock, hip-hop. |
| `playlist_subgenre`         | object        | Subgenre dari playlist, lebih spesifik dari genre utama. |
| `danceability`              | float64       | Seberapa cocok lagu untuk menari (0–1). |
| `energy`                    | float64       | Tingkat energi dan intensitas lagu (0–1). |
| `key`                       | int64         | Nada dasar lagu dalam angka 0–11 (C sampai B). |
| `loudness`                  | float64       | Volume rata-rata lagu dalam desibel (dB), biasanya negatif. |
| `mode`                      | int64         | Tangga nada lagu: 1 = mayor, 0 = minor. |
| `speechiness`              | float64       | Proporsi unsur ucapan (0–1); tinggi jika banyak spoken word/rap. |
| `acousticness`             | float64       | Probabilitas lagu bersifat akustik (0–1). |
| `instrumentalness`         | float64       | Probabilitas lagu tanpa vokal (0–1). |
| `liveness`                 | float64       | Probabilitas lagu direkam live (0–1). |
| `valence`                  | float64       | Suasana emosional lagu (0 = sedih, 1 = ceria). |
| `tempo`                    | float64       | Tempo lagu dalam BPM (beats per minute). |
| `duration_ms`              | int64         | Durasi lagu dalam milidetik. Contoh: 240000 = 4 menit. |
"""

df.shape

"""## Deskripsi Data"""

df_filtered = pd.DataFrame(df)

df_filtered.describe()

"""Fungsi describe() digunakan untuk menampilkan ringkasan statistik dari setiap kolom dalam dataset, yang mencakup:

- Count menunjukkan jumlah data yang tersedia pada masing-masing kolom.
- Mean menyatakan nilai rata-rata dari data.
- Std adalah singkatan dari standar deviasi, yang menggambarkan sebaran atau variasi data
- Min menunjukkan nilai terkecil pada kolom tersebut.
- 25% adalah nilai kuartil pertama, yang berarti 25% data berada di bawah angka ini.
- 50% adalah kuartil kedua atau median, yaitu nilai tengah dari data.
- 75% merupakan kuartil ketiga, artinya 75% data berada di bawah nilai ini.
- Max menunjukkan nilai tertinggi dalam kolom tersebut.

| **Kolom**             | **Deskripsi** |
|----------------------|---------------|
| **`track_popularity`** | lagu berkisar dari 0 hingga 100, yang dihitung berdasarkan aktivitas pengguna seperti streaming dan penyimpanan lagu. Nilai rata-ratanya adalah sekitar 42,477 di mana semakin tinggi skornya, semakin populer lagu tersebut. |
| **`danceability`**     | Kolom yang menunjukkan seberapa cocok sebuah lagu untuk berdansa. Skala nilainya antara 0.0 sampai 1.0, dengan nilai rata-rata sekitar 0.655. Lagu dengan nilai danceability tinggi biasanya memiliki beat, tempo, dan ritme yang membuatnya mudah untuk bergerak dan menari. |
| **`energy`**           | Kolom yang mengukur tingkat intensitas dan semangat lagu, juga pada skala 0.0 sampai 1.0, dengan rata-rata sekitar 0.699. Lagu yang memiliki energy tinggi terdengar cepat, keras, dan penuh aktivitas, memberikan kesan semangat yang kuat. |
| **`key`**              | Nada dasar lagu yang berupa angka antara 0 sampai 11, di mana 0 mewakili nada C dan 11 mewakili nada B. Rata-rata nilai key yang ditemukan adalah sekitar 5,374. |
| **`loudness`**         | Kolom yang menjelaskan tentang volume rata-rata lagu diukur dalam desibel (dB), biasanya bernilai negatif karena merupakan tingkat suara relatif. Nilai loudness terendah adalah sekitar -46.45 dB dan tertinggi 1.28 dB, dengan rata-rata sekitar -6.72 dB. Semakin mendekati 0 dB, lagu terdengar semakin keras. |
| **`mode`**             | Kolom yang mengindikasikan jenis tangga nada lagu, yaitu mayor atau minor. Mode bernilai 1 menunjukkan lagu dengan tangga nada mayor yang ceria, sedangkan 0 menunjukkan tangga nada minor yang cenderung suram atau murung. Secara rata-rata, lebih banyak lagu yang menggunakan mode mayor. |
| **`speechiness`**      | Kolom untuk mengukur proporsi unsur ucapan dalam lagu, dengan skala dari 0.0 hingga 1.0 dan rata-rata sekitar 0.107. Nilai tinggi pada fitur ini biasanya menunjukkan lagu dengan banyak kata, seperti rap atau spoken word.. |
| **`acousticness`**     | Probabilitas lagu bersifat akustik (tanpa elemen elektronik). Memiliki nilai antara 0.0 sampai 1.0, dengan rata-rata 0.175. Nilai mendekati 1 berarti lagu sangat akustik. |
| **`instrumentalness`** | Menunjukkan kemungkinan lagu tanpa vokal manusia (instrumental). Dengan skala 0.0 hingga 1.0 dan rata-rata 0.084, nilai tinggi berarti lagu tersebut cenderung instrumental. |
| **`liveness`**         | Mengindikasikan apakah sebuah lagu direkam secara live, di hadapan penonton. Skala nilainya 0.0 sampai 1.0, dengan rata-rata sekitar 0.19. Nilai di atas 0.8 menandakan kemungkinan besar lagu tersebut merupakan rekaman live.|
| **`valence`**          | Mengukur suasana emosional lagu dari 0 (sedih) sampai 1 (ceria dan positif). Rata-rata valence adalah sekitar 0.51, yang berarti lagu-lagu cenderung memiliki keseimbangan antara suasana sedih dan ceria. |
| **`tempo`**            | Mengacu pada kecepatan lagu dalam beats per minute (BPM), dengan rentang dari 0 sampai sekitar 239 BPM dan rata-rata 120,88 BPM. Misalnya, 120 BPM dianggap sebagai tempo sedang. |
| **`duration_ms`**      | Menunjukkan durasi lagu dalam milidetik, dengan nilai terkecil sekitar 4000 ms (4 detik) dan terbesar sekitar 517810 ms (lebih dari 8 menit). Rata-rata durasi lagu adalah sekitar 225.800 ms, atau sekitar 3 menit 46 detik. |

## Exploratory Data Analysis (EDA)

### Analisis Berdasarkan Top 10 Lagu Terpopuler dari Playlist "Global Top 50 | 2020 Hits"
"""

global_top_50 = df[df["playlist_name"].str.contains("Global Top 50", case=False, na=False)]

# Urutkan berdasarkan popularitas dan ambil 10 teratas
top_10_global = global_top_50.sort_values(by="track_popularity", ascending=False).head(10)

# Tampilkan hasil
print(top_10_global[["track_name", "track_artist", "track_popularity", "playlist_name"]])

plt.figure(figsize=(12, 6))
plt.barh(
    top_10_global["track_name"] + " - " + top_10_global["track_artist"],
    top_10_global["track_popularity"],
    color="skyblue"
)
plt.xlabel("Popularitas")
plt.title("10 Lagu Terpopuler di Playlist Global Top 50")
plt.gca().invert_yaxis()  # Lagu paling populer di atas
plt.tight_layout()
plt.show()

"""**Insight** :
- Dari output diatas kita bisa lihat 10 Lagu Terpopuler di Playlist Global Top 50 | 2020 Hits adalah :    
  -  Dance Monkey
  - ROXANNE  
  -  bad guy
  - No Idea
  - Futsal Shuffle 2020
  - 10,000 Hours (with Justin Bieber)
  - Suicidal  
  - Good as Hell (feat. Ariana Grande) - Remix
  -  Own It (feat. Ed Sheeran & Burna Boy)
  - Sweet but Psycho           
- Lagu “Dance Monkey” oleh Tones and I memiliki track_popularity tertinggi yaitu 100, menunjukkan bahwa lagu ini sangat populer secara global pada tahun 2020.
- Pada peringkat 1 dan 2 yaitu Dance Monkey - Tones and I dan Roxanne - Arizona Zervas memiliki beda selisih yang sedikit beda 1 nilai yaitu 100 dan 99.
- Popularitas lagu-lagu dalam daftar ini tidak menunjukkan perbedaan yang signifikan, dengan rentang skor antara 87 hingga 100. Hal ini mencerminkan bahwa persaingan antar lagu sangat ketat, di mana setiap track memiliki performa yang hampir setara dalam hal jumlah pemutaran dan tingkat keterlibatan pendengar. Skor popularitas yang tinggi secara konsisten juga menunjukkan bahwa lagu-lagu ini mendapatkan eksposur yang luas dan sering diputar oleh pengguna Spotify di seluruh dunia, menjadikannya bagian dari arus utama musik global pada tahun 2020.

### Analisis Berdasarkan 5 Genre Lagu Teratas dengan Rata-rata memiliki Popularitas Tertinggi
"""

top_5_genre = df.groupby("playlist_genre")["track_popularity"].mean().sort_values(ascending=False).head(5)

# Tampilkan di terminal
print(top_5_genre)

# Visualisasi
plt.figure(figsize=(10, 6))
top_5_genre.plot(kind='bar', color='steelblue', edgecolor='black')

plt.title("5 Genre dengan Rata-rata Popularitas (Rating) Tertinggi")
plt.xlabel("Genre Playlist")
plt.ylabel("Rata-rata Popularitas")
plt.xticks(rotation=45, ha='right')
plt.tight_layout()
plt.show()

"""**Insight** :
- Genre pop mencatat nilai tertinggi sebesar 47.74, menandakan dominasinya dalam playlist Spotify. Popularitas ini mencerminkan preferensi global terhadap musik pop yang dikenal catchy, mudah diingat, dan menjangkau berbagai kalangan.
- Nilai kelima genre berada dalam kisaran 41–47, menunjukkan bahwa meskipun pop mendominasi, diversitas genre di playlist Spotify cukup merata. Hal ini mencerminkan bahwa pengguna tetap mengeksplorasi berbagai jenis musik, menjadikan Spotify sebagai platform yang inklusif bagi musisi dari beragam latar belakang genre.

###Analisis Korelasi antara Energy dan Popularitas Lagu
"""

corr_energy = df["energy"].corr(df["track_popularity"])
print(f"Korelasi energy dan popularitas: {corr_energy:.2f}")

# Visualisasi
plt.figure(figsize=(8, 5))
sns.regplot(x="energy", y="track_popularity", data=df, scatter_kws={"alpha":0.3}, line_kws={"color":"red"})
plt.title("Korelasi Energy dan Popularitas Lagu")
plt.xlabel("Energy")
plt.ylabel("Track Popularity")
plt.show()

"""**Insight** :
- Nilai korelasi sebesar -0.11 menunjukkan hubungan negatif yang sangat lemah antara energi lagu dan popularitasnya.
- Scatter plot memperlihatkan titik-titik yang tersebar luas tanpa pola yang konsisten, menandakan tidak adanya tren linier yang kuat.
- Lagu dengan energy tinggi tidak selalu populer, dan lagu dengan energy rendah juga bisa sangat populer. Ini menunjukkan bahwa tingkat energi bukanlah faktor dominan dalam menentukan popularitas lagu.

## Data Quality Verification
"""

df.isnull().sum()

"""**insight** :
- Dari output tersebut dapat kita lihat terdapat missing value sebanyak 15 data, nantinya missing value ini akan kita hapus karena jumlah nya sedikit jadi tidak akan terlalu mempengaruhi kualitas analisis.    
"""

df.duplicated().sum()

"""**insight** :
- Tidak terdapat data yang duplikat     
"""

numerical_features = df.select_dtypes(include=['int64', 'float64']).columns.tolist()

categorical_features = df.select_dtypes(include=['object', 'bool']).columns.tolist()

print("\nFitur Numerik:")
print(numerical_features)

print("\nFitur Kategorikal:")
print(categorical_features)

"""**insight** :
- Mengelompokkan numerical_features pada kolom dengan tipe data int64 dan float64    
- Mengelompokkan categorical_features pada kolom dengan tipe data object bool    
"""

def count_total_outliers_iqr(data):
    total_outliers = 0

    # Iterasi hanya pada kolom numerik
    for column in data.select_dtypes(include=['int64', 'float64']).columns:
        Q1 = data[column].quantile(0.25)
        Q3 = data[column].quantile(0.75)
        IQR = Q3 - Q1

        lower_bound = Q1 - 1.5 * IQR
        upper_bound = Q3 + 1.5 * IQR

        # Hitung jumlah outlier untuk kolom ini
        outliers = data[(data[column] < lower_bound) | (data[column] > upper_bound)]
        total_outliers += outliers.shape[0]

    return total_outliers

jumlah_outlier = count_total_outliers_iqr(df)
print(f"Jumlah total outlier dalam dataset: {jumlah_outlier}")

n_cols = 3  # jumlah kolom per baris
n_rows = (len(numerical_features) + n_cols - 1) // n_cols  # hitung jumlah baris
plt.figure(figsize=(n_cols * 5, n_rows * 3))  # ukuran figure

# Plot boxplot dalam grid
for i, col in enumerate(numerical_features):
    plt.subplot(n_rows, n_cols, i + 1)
    sns.boxplot(y=df[col], color='lightgreen')  # y-axis agar horizontalnya ringkas
    plt.title(col)
    plt.tight_layout()

plt.show()

"""**Insight** :
1. track_popularity
  - Beberapa outlier di bagian bawah (mendekati 0) dan di bagian atas (mendekati 100). Ini menunjukkan ada beberapa trek yang sangat tidak populer dan beberapa yang sangat populer.
2. danceability
  - Banyak outlier di bagian bawah (nilai danceability yang sangat rendah), menunjukkan ada beberapa trek yang tidak terlalu enak didengar.
3. energy
  - Banyak outlier di bagian bawah (nilai energy yang sangat rendah), menunjukkan ada beberapa trek dengan energi yang sangat rendah.
4. key
  - Tidak ada outlier yang signifikan dalam fitur ini, yang mungkin menunjukkan distribusi yang relatif merata atau terdistribusi dengan baik di antara 12 kunci musik (0-11).
5. loudness
  - Banyak outlier di bagian bawah (nilai loudness yang sangat rendah, yaitu sangat pelan), menunjukkan ada beberapa trek yang sangat pelan.
6. mode
  - Berada di sekitar 1.0. Ini menunjukkan bahwa sebagian besar, jika tidak semua, trek dalam dataset berada dalam mode Mayor (diwakili oleh 1). Mode Minor (diwakili oleh 0) tampaknya sangat jarang atau tidak ada dalam dataset ini.
7. speechiness
  - Banyak outlier di bagian atas, menunjukkan ada beberapa trek dengan proporsi kata yang diucapkan yang sangat tinggi.
8. acousticness
  - Banyak outlier di bagian atas, menunjukkan ada beberapa trek yang sangat akustik.
9. instrumentalness
  - Sangat banyak outlier di bagian atas, menunjukkan ada banyak trek yang sepenuhnya instrumental (yaitu tidak ada vokal). Nilai 1.0 berarti instrumental penuh.
10. liveness
  - Banyak outlier di bagian atas, mendekati 1.0. Ini mengindikasikan ada beberapa trek yang direkam secara langsung (memiliki liveness yang tinggi).
11. valence
  - Beberapa outlier di bagian bawah (mendekati 0) dan di bagian atas (mendekati 1.0), menunjukkan ada beberapa trek yang sangat sedih/negatif dan beberapa yang sangat ceria/positif.
12. tempo
  - Beberapa outlier di bagian bawah (tempo sangat lambat) dan di bagian atas (tempo sangat cepat), menunjukkan variasi dalam kecepatan musik.
13. duration_ms
  - Banyak outlier di bagian bawah (trek yang sangat pendek) dan di bagian atas (trek yang sangat panjang), menunjukkan variasi durasi trek yang signifikan.

# Data Preparation

### Data Cleaning

#### Menangani Data Missing Value
"""

df.isnull().sum()

df = df.dropna()

df.isnull().sum()

"""**Insight** :
- Setelah dilakukan penghapusan data yang missing value sudah tidak terdapat lagi data yang missing value

### Mengubah duration_ms menjadi menit
"""

# Mengubah yang tadinya milisecon menjadi menit lalu dibulatkan menjadi dua angka dibelakang koma
df.loc[:, 'duration_min'] = (df['duration_ms'] / (1000 * 60)).round(2)

# Tampilkan hasilnya
print(df[['duration_ms', 'duration_min']].head())

"""###Menghapus Kolom Yang Tidak Diperlukan"""

columns_to_drop = [
    'track_id',
    'track_album_id',
    'track_album_name',
    'track_album_release_date',
    'playlist_id',
    'playlist_subgenre'
]

# Menghapus kolom-kolom tersebut
df_cleaned = df.drop(columns=columns_to_drop)

# Menampilkan kolom yang tersisa
print(df_cleaned.columns)

"""####Melakukan Perubahan pada kolom Artist"""

import ast

# Bersihkan kolom 'artists'
def clean_artist_string(artist_str):
    try:
        if isinstance(artist_str, str):
            artist_list = ast.literal_eval(artist_str)
            if isinstance(artist_list, list):
                return ', '.join(artist_list)
        elif isinstance(artist_str, list):
            return ', '.join(artist_str)
    except:
        pass
    return str(artist_str)

df['cleaned_artists'] = df['track_artist'].apply(clean_artist_string)

# Buat unique_song_key dan hilangkan duplikasi
df['unique_song_key'] = df['cleaned_artists'] + " - " + df['track_name']
df = df.drop_duplicates(subset='unique_song_key', keep='first').reset_index(drop=True)

# Gabungkan fitur konten (ubah sesuai kolom yang tersedia)
df['combined_features'] = (
    df['cleaned_artists'].fillna('') + ' ' +
    df['playlist_genre'].fillna('') + ' ' +
    df['playlist_subgenre'].fillna('')
)

"""###Standarisasi"""

from sklearn.preprocessing import StandardScaler

# Pilih kolom fitur numerik
feature_cols = ['danceability', 'energy', 'loudness', 'speechiness',
                'acousticness', 'instrumentalness', 'liveness',
                'valence', 'tempo']

# Pastikan semua kolom ada di df
df_features = df[feature_cols].copy()

# Normalisasi fitur numerik
scaler = StandardScaler()
X_scaled = scaler.fit_transform(df_features)

# Simpan dalam DataFrame dengan index yang sama
X_scaled_df = pd.DataFrame(X_scaled, index=df['unique_song_key'], columns=feature_cols)

"""# Modeling

###Menerapkan Cosine Similarity
"""

from sklearn.metrics.pairwise import cosine_similarity

cos_sim_matrix = cosine_similarity(X_scaled_df)

cos_sim_matrix

cosine_sim_df = pd.DataFrame(
    cos_sim_matrix,
    index=df['unique_song_key'],
    columns=df['unique_song_key']
)

def recommend_by_identifier(song_identifier, top_n=10):
    # Cek apakah lagu tersedia di indeks matriks
    if song_identifier not in cosine_sim_df.index:
        return f"Lagu '{song_identifier}' tidak ditemukan dalam similarity matrix."

    similarity_series = cosine_sim_df.loc[song_identifier]

    # Hapus diri sendiri dari perbandingan
    similarity_series = similarity_series.drop(song_identifier, errors='ignore')

    # Urutkan dari skor tertinggi
    similarity_series = similarity_series.sort_values(ascending=False)

    return similarity_series.head(top_n)

from sklearn.metrics.pairwise import cosine_similarity
import pandas as pd

# Buat matriks cosine similarity
cos_sim_matrix = cosine_similarity(X_scaled_df)

# Buat DataFrame untuk menyimpan similarity antar lagu
cosine_sim_df = pd.DataFrame(
    cos_sim_matrix,
    index=df['unique_song_key'],
    columns=df['unique_song_key']
)

# Tampilkan bentuk (dimensi) matriks similarity
print('Shape of cosine similarity matrix:', cosine_sim_df.shape)

# Contoh: tampilkan sebagian matriks secara acak
display(cosine_sim_df.sample(10, axis=0).sample(5, axis=1))

"""# Evaluation dan Inference

###Inference
"""

query_song = "Alex & Sierra - Little Do You Know"
recommendations = recommend_by_identifier(query_song, top_n=5)

if isinstance(recommendations, str):
    print(recommendations)
else:
    print(f"Rekomendasi lagu mirip dengan '{query_song}':\n")
    for idx, (song_key, score) in enumerate(recommendations.items(), 1):
        print(f"{idx}. {song_key} (Similarity: {round(score, 2)})")

"""###Evaluation"""

ground_truth = {
    "Alex & Sierra - Little Do You Know": [
        "Dean Lewis - Waves - Guitar Acoustic",
        "Angus Maude - Want",
        "Ben Platt - In Case You Don't Live Forever",
        "Grace VanderWaal - I Don't Know My Name",
        "Juan Gabriel - Abrázame Muy Fuerte"
    ]
}

def evaluate_recommendation_metrics(query_song, ground_truth, k=5):
    recommended = recommend_by_identifier(query_song, top_n=k)

    if isinstance(recommended, str):
        print(recommended)
        return None

    # Normalisasi ground truth
    true_set = set(song.lower().strip() for song in ground_truth.get(query_song, []))

    # Normalisasi hasil rekomendasi (pasti Series → ambil .index)
    if isinstance(recommended, pd.Series):
        rec_set = set(song.lower().strip() for song in recommended.index)
    elif isinstance(recommended, dict):
        rec_set = set(song.lower().strip() for song in recommended.keys())
    elif isinstance(recommended, list) and isinstance(recommended[0], tuple):
        rec_set = set(song[0].lower().strip() for song in recommended)
    else:
        rec_set = set(song.lower().strip() for song in recommended)

    relevant_found = list(true_set.intersection(rec_set))

    precision = len(relevant_found) / k if k > 0 else 0
    recall = len(relevant_found) / len(true_set) if len(true_set) > 0 else 0
    f1 = 2 * (precision * recall) / (precision + recall) if (precision + recall) > 0 else 0

    results = {
        f'Precision@{k}': round(precision, 4),
        f'Recall@{k}': round(recall, 4),
        f'F1-Score@{k}': round(f1, 4),
        'Relevant Found': relevant_found
    }

    return results

metrics = evaluate_recommendation_metrics("Alex & Sierra - Little Do You Know", ground_truth, k=5)
from pprint import pprint
pprint(metrics)

"""# Menjawab Problems

###1. Apa saja top 10 Lagu dari Playlist "Global Top 50 | 2020 Hits"?
"""

global_top_50 = df[df["playlist_name"].str.contains("Global Top 50", case=False, na=False)]

# Urutkan berdasarkan popularitas dan ambil 10 teratas
top_10_global = global_top_50.sort_values(by="track_popularity", ascending=False).head(10)

# Tampilkan hasil
print(top_10_global[["track_name", "track_artist", "track_popularity", "playlist_name"]])

plt.figure(figsize=(12, 6))
plt.barh(
    top_10_global["track_name"] + " - " + top_10_global["track_artist"],
    top_10_global["track_popularity"],
    color="skyblue"
)
plt.xlabel("Popularitas")
plt.title("10 Lagu Terpopuler di Playlist Global Top 50")
plt.gca().invert_yaxis()  # Lagu paling populer di atas
plt.tight_layout()
plt.show()

"""Berikut adalah daftar 10 lagu terpopuler dari playlist "Global Top 50 | 2020 Hits" berdasarkan tingkat popularitasnya. Lagu Dance Monkey oleh Tones and I menempati posisi teratas dengan skor popularitas sempurna yaitu 100, diikuti oleh ROXANNE dari Arizona Zervas dengan skor 99. Lagu-lagu lain seperti bad guy oleh Billie Eilish, No Idea dari Don Toliver, dan Futsal Shuffle 2020 oleh Lil Uzi Vert juga termasuk dalam daftar dengan skor popularitas tinggi di atas 87. Keseluruhan lagu dalam daftar ini menunjukkan popularitas yang sangat tinggi, mencerminkan eksposur luas dan banyaknya pemutaran di seluruh dunia. Hal ini mengindikasikan bahwa playlist tersebut memang berisi lagu-lagu hits yang sangat diminati oleh pendengar Spotify secara global pada tahun 2020.

### 2. Apa saja 5 Genre Lagu Teratas dengan Rata-rata memiliki Popularitas Tertinggi?

Dapat dilihat pada EDA Analisis Berdasarkan 5 Genre Lagu Teratas dengan Rata-rata memiliki Popularitas Tertinggi :   

Berdasarkan analisis data, lima genre lagu dengan rata-rata popularitas tertinggi dipimpin oleh genre pop yang memiliki skor rata-rata sekitar 47,74, menunjukkan bahwa pop tetap menjadi genre yang paling banyak diminati dan sering diputar oleh pendengar Spotify secara global. Di posisi berikutnya adalah genre latin dengan rata-rata popularitas sekitar 47,03, yang menunjukkan bahwa musik latin juga memiliki basis penggemar yang kuat dan eksposur yang luas. Genre rap menempati peringkat ketiga dengan rata-rata popularitas sekitar 43,22, diikuti oleh rock dan R&B yang masing-masing memiliki rata-rata popularitas sekitar 41,73 dan 41,22. Meskipun terdapat variasi, perbedaan popularitas antar genre ini tidak terlalu jauh, mengindikasikan bahwa pengguna Spotify memiliki preferensi musik yang beragam. Namun, jelas terlihat bahwa genre pop mendominasi pasar dengan pengaruh yang sangat besar, sementara genre latin dan rap juga menunjukkan eksistensi yang signifikan di dalam playlist dan pilihan pendengar.

### 3. Apakah ada Korelasi antara Energy dan Popularitas Lagu?
"""

corr_energy = df["energy"].corr(df["track_popularity"])
print(f"Korelasi energy dan popularitas: {corr_energy:.2f}")

# Visualisasi
plt.figure(figsize=(8, 5))
sns.regplot(x="energy", y="track_popularity", data=df, scatter_kws={"alpha":0.3}, line_kws={"color":"red"})
plt.title("Korelasi Energy dan Popularitas Lagu")
plt.xlabel("Energy")
plt.ylabel("Track Popularity")
plt.show()

"""Dapat dilihat pada EDA Analisis Korelasi antara Energy dan Popularitas Lagu :

Berdasarkan hasil perhitungan korelasi antara variabel energy dan popularitas lagu, diperoleh nilai korelasi sebesar -0.11. Nilai ini menunjukkan adanya korelasi negatif yang sangat lemah antara tingkat energy dalam sebuah lagu dengan popularitasnya. Dengan kata lain, semakin tinggi atau rendah energi sebuah lagu tidak berpengaruh signifikan terhadap tingkat popularitasnya di Spotify. Hal ini mengindikasikan bahwa faktor energy saja tidak cukup untuk menentukan seberapa populer sebuah lagu di kalangan pendengar.

Visualisasi berupa scatter plot dengan garis regresi juga mendukung temuan ini. Titik-titik data tersebar cukup merata di seluruh rentang nilai energy dan popularitas, tanpa pola tren naik atau turun yang jelas. Garis regresi yang cenderung datar mempertegas bahwa tidak ada hubungan linier kuat antara energy lagu dan seberapa sering lagu tersebut diputar atau diminati oleh pengguna. Dengan demikian, energy bukanlah indikator utama yang dapat digunakan untuk memprediksi popularitas lagu.

# Referensi

1. Nijkamp, R. (2018). The relation between audio features and popularity of songs on Spotify. Undergraduate Thesis, University of Twente.
2. Smith, A., & Garcia, M. (2019). The impact of genre diversity on streaming numbers: A Spotify case study. International Journal of Music Business Research, 8(1), 23-39.
3. Huang, Y., & Kuo, C. (2020). Analyzing Music Popularity and Listener Preferences Using Spotify Data. Journal of Data Science and Music Analytics, 5(2), 45-58.
"""